## Build and Package Manager Tools

### Understanding Artifacts

**What is an Artifact?**
An artifact is a file generated by a build process, containing either binary or source code crucial for deploying an application. Examples include JAR or WAR files produced by Java.

**Inside a JAR File:**
A JAR file is essentially a zip file with a manifest file, classes, and resources of the application. The manifest file holds essential information like the main class and dependencies. For instance, Maven in Java uses the pom.xml as its manifest file, while Node.js relies on package.json.

### Artifactory: Repository for Artifacts

**What is an Artifactory and its Significance?**
An Artifactory is a repository designed to store artifacts. Notable examples include Nexus. This repository holds both the built artifacts and their dependencies. Additionally, platforms like Nexus support the storage of Docker images, providing a comprehensive solution for artifact management.

### The Universal Appeal of Docker

**Why Docker?**
Docker revolutionizes the deployment process by offering universality. A Docker image can seamlessly run on any machine, simplifying artifact management. It unifies the development, testing, and production environments, enabling the use of the same Docker image across these stages. Docker significantly streamlines the deployment lifecycle, making it a powerful tool in modern software development.
### Building the Code

Building and packaging code efficiently involves several steps:

1. **Compiling:**
   - Compile source code to executable code.

2. **Compression:**
   - Compress hundreds of files into a single file for easier management.

3. **Artifactory Repository:**
   - Utilize Artifactory repositories like Nexus or JFrog Artifactory.
   - Store artifacts to deploy multiple times, ensure backups, etc.

4. **Artifact Types:**
   - Artifact files vary for each programming language.
   - Example: For Java, the artifact is a JAR file containing the entire code along with dependencies.

### Installing Build Tools

**Install Java:**
```bash
# Using the package manager
sudo apt install default-jdk

# Setting JAVA_HOME variable
# Add the following to your ~/.profile
if [ -d "/usr/lib/jvm/default-java/bin" ]; then
    JAVA_HOME="/usr/lib/jvm/default-java"
    PATH="$JAVA_HOME/bin:$PATH"
fi
```

**Install Maven:**
[Follow instructions here](https://maven.apache.org/install.html)

**Install Gradle:**
- Use IntelliJ or follow the official documentation.

**Install Node + npm:**
- Utilize Node Version Manager for efficient Node.js management.

**Download IntelliJ:**
- Visit the [download page](https://www.jetbrains.com/idea/download/) and choose the Community version.

### Building an Artifact

**Build Tools for Java Applications:**
- Maven (uses XML)
- Gradle (uses Groovy)

**With Gradle:**
- Use `./gradlew` present in the repository.
- Execute `./gradlew build` to generate the `.jar` file in `./build/libs/`.

**With Maven:**
- Configure the `pom.xml` file with the `<build>` tag.
- Execute `mvn install` to generate the `.jar` file in the `./target/` folder.

### Build Tools for Development

**Managing Dependencies:**
- With Maven: `pom.xml`
- With Gradle: `build.gradle`
- Repository: [https://mvnrepository.com/](https://mvnrepository.com/)

### Running the Application

**Command to Run a .jar File:**
```bash
java -jar <file.jar>
```

### Building JS Application

**Backend:**
- No special artifact type.
- Use npm or yarn for dependency management.
- Utilize npm repository for dependencies.

**Commands:**
```bash
# Install dependencies (inside project's directory)
npm install

# When package.json is properly configured
npm start   # Start the application
npm stop    # Stop the application
npm test    # Run the tests
npm publish # Publish the artifact

# Create an artifact file
npm pack    # Creates a tar file
```

**What Does the Zip/Tar File Include?**
- Application code but not the dependencies.
- To run the app on the server, install dependencies first, unpack zip/tar, and run the app.

**Frontend:**
- Transpile and compress/minify Frontend/React code.
- Utilize build tools/bundler (e.g., webpack, grunt, etc.).

**Commands:**
```bash
# Install dependencies (inside project's directory)
npm install

# Assuming webpack is installed and "build" in package.json calls webpack
# Bundles the code minified/transpiled.
npm run build
```

**Integration with Java Backend:**
- Bundle the app with Webpack.
- Manage dependencies with npm or yarn.
- Package everything into a WAR file.

### Common Concepts and Differences of Build Tools

| Language    | Dependency Manager |
|-------------|---------------------|
| Java        | Maven or Gradle     |
| JavaScript  | npm or yarn         |
| Python      | pip                 |

**Pattern in All Tools:**
- Dependency file.
- Repository for dependencies.
- Command line tool.
- Package managers.

### Publish an Artifact

**Publish Artifact into an Artifact Repository:**
- Build tools provide commands for publishing.
- Download (curl, wget) the artifact from anywhere.

### Build Tools & Docker

- Build and move only one artifact type: a Docker image.
- No need for multiple repositories for different file types; just one for Docker images.
- No need to install dependencies on the server; execute the install command inside the Docker image.
- Docker standardizes the way software artifacts are published.
- Docker image serves as an alternative for all other artifact types.

### Build Tools for DevOps

**Why DevOps Engineers Should Know Build Tools:**
- Assist developers in building applications.
- Configure CI/CD pipelines.
- Execute tests on build servers.
- Build and package into Docker images.

Knowing these tools is crucial for efficient collaboration between development and operations, ensuring seamless integration and deployment of applications.